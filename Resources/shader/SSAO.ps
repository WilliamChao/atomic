#version 410 compatibility

#version 330 core

    

struct  RenderStates
{
    mat4 ModelViewProjectionMatrix;
    vec4 CameraPosition;
    vec4 CameraDirection;
    vec4 Color;

    vec2 ScreenTexcoord;
    vec2 ScreenSize;
    vec2 RcpScreenSize;
    float AspectRatio;
    float RcpAspectRatio;
    float Frame;
    int Level;
    int ShowMultiresolution;
};

struct  FXAAParams
{
    vec4 fxaaConsolePosPos;
    vec4 fxaaConsoleRcpFrameOpt;
    vec4 fxaaConsoleRcpFrameOpt2;
    vec4 fxaaConsole360RcpFrameOpt2;
    vec4 fxaaConsole360ConstDir;
    vec2 fxaaQualityRcpFrame;
    float fxaaQualitySubpix;
    float fxaaQualityEdgeThreshold;
    float fxaaQualityEdgeThresholdMin;
    float fxaaConsoleEdgeSharpness;
    float fxaaConsoleEdgeThreshold;
    float fxaaConsoleEdgeThresholdMin;
};

struct  FadeParams
{
    vec4 Color;
};

struct  FillParams
{
    vec4 Color;
};

struct  MultiresolutionParams
{
    ivec4 Level;
    vec4 Threshold;
};

struct  DebugShowBufferParams
{
    vec2 BottomLeft; 
    vec2 UpperRight; 
    vec2 ColorRange; 
};

    layout(std140) uniform render_states
    {
        RenderStates u_RS;
    };

    uniform sampler2D u_ColorBuffer;
    uniform sampler2D u_NormalBuffer;
    uniform sampler2D u_PositionBuffer;
    uniform sampler2D u_GlowBuffer;
    uniform sampler2D u_BackBuffer;
    uniform sampler2D u_RandomBuffer;
    uniform sampler2D u_ParamBuffer;

    

    

    

float SmoothInterpolation2(float v)
{
    return v < 0.5 ? 2.0*v*v : -1.0+4.0*v-2*v*v;
}

float SmoothInterpolation(float v, int n)
{
    return v < 0.5 ? pow(2.0*v, n) : 1.0 - pow(2.0-2.0*v, n);
}

in vec2 vs_Texcoord;

uniform float totStrength = 1.38;
uniform float strength = 0.05;
uniform float offset = 18.0;
uniform float falloff = 0.000002;
uniform float rad = 0.006;

const float invSamples = 1.0/16.0;

layout(location=0) out vec4 ps_FragColor;
layout(location=1) out vec4 ps_FragColor1;
layout(location=2) out vec4 ps_FragColor2;

void main()
{
    ps_FragColor = texture2D(u_ColorBuffer, vs_Texcoord);

    
    vec3 pSphere[16] = vec3[](vec3(0.53812504, 0.18565957, -0.43192),vec3(0.13790712, 0.24864247, 0.44301823),vec3(0.33715037, 0.56794053, -0.005789503),vec3(-0.6999805, -0.04511441, -0.0019965635),vec3(0.06896307, -0.15983082, -0.85477847),vec3(0.056099437, 0.006954967, -0.1843352),vec3(-0.014653638, 0.14027752, 0.0762037),vec3(0.010019933, -0.1924225, -0.034443386),vec3(-0.35775623, -0.5301969, -0.43581226),vec3(-0.3169221, 0.106360726, 0.015860917),vec3(0.010350345, -0.58698344, 0.0046293875),vec3(-0.08972908, -0.49408212, 0.3287904),vec3(0.7119986, -0.0154690035, -0.09183723),vec3(-0.053382345, 0.059675813, -0.5411899),vec3(0.035267662, -0.063188605, 0.54602677),vec3(-0.47761092, 0.2847911, -0.0271716));

    vec2 uv = vs_Texcoord;
   
   vec3 fres = normalize((texture2D(u_RandomBuffer, uv*offset).xyz*2.0) - vec3(1.0));
   vec4 currentPixelSample = texture2D(u_NormalBuffer, uv);
   float currentPixelDepth = texture2D(u_DepthBuffer, uv).r;

   
   vec3 ep = vec3(uv.xy, currentPixelDepth);
   
   vec3 norm = currentPixelSample.xyz;

   float bl = 0.0;
   
   float radD = rad/currentPixelDepth;

   vec3 ray, se, occNorm;
   float occluderDepth, depthDifference, normDiff;

   for(int i=0; i<16; ++i)
   {
      
      ray = radD*reflect(pSphere[i],fres);

      
      se = ep + sign(dot(ray,norm) )*ray;

      
      occNorm = texture2D(u_NormalBuffer, se.xy).rgb;
      occluderDepth = texture2D(u_DepthBuffer, se.xy).r;

      
      depthDifference = currentPixelDepth-occluderDepth;

      

      normDiff = (1.0-dot(occNorm,norm));
      
      bl += step(falloff,depthDifference)*normDiff*(1.0-smoothstep(falloff,strength,depthDifference));
   }

   
   float ao = 1.0-totStrength*bl*invSamples;
   ps_FragColor1 = vec4(ao, ao, ao, 1.0);
   ps_FragColor2 = vec4(ps_FragColor.rgb*ao, 1.0);
}

