<!DOCTYPE html>
<html>
<head>
<title>atomic: level editor</title>

<script type="x-shader/x-vertex" id="vs_simple"> 
attribute vec3 ia_position;
uniform mat4 u_proj;
uniform mat4 u_trans;
uniform vec3 u_size;
uniform vec4 u_color;
varying vec4 vs_color;
void main()
{
    vs_color = u_color;
    gl_Position = u_proj * (u_trans* vec4(ia_position*u_size, 1.0));
}
</script>

<script type="x-shader/x-fragment" id="ps_simple">
precision mediump float;
varying vec4 vs_color;
void main()
{
    gl_FragColor = vs_color;
}
</script>

<script type="text/javascript" src="prototype.js"></script>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript">

var EditMode = {
    Observer : 0,
    Editor : 1,
};


var EntityClassID = {
    Unknown : 0,
    Player : 1,
    Enemy : 2,
    Obstacle : 3,
};
var EntityClassColor = [
    [0.0, 0.0, 0.0, 0.0],
    [0.2, 0.2, 1.0, 0.5],
    [1.0, 0.2, 0.2, 0.5],
    [0.3, 0.3, 0.3, 0.5],
];
var EntityClassColor2D = [
    "#000000",
    "#3333FF",
    "#FF3333",
    "#444444",
];
var FieldX = 3.0;
var FieldY = 3.0;

var gl;
var ext;

var FPSTimer;
var EntitiesTimer;
var loading = false
var frame = 0;
var delay = 1000/30;
var starttime = new Date().getTime();

var mouse = {
    screen:     vec2.create(),
    screen_prev:vec2.create(),
    gl:         vec2.create(),
    gl_prev:    vec2.create(),
    dragging:   false,
    button:     0,
};

var camera = {
    pos:    vec3.create(),
    target: vec3.create(),
    up:     vec3.create(),
    aspect: 1.0,
    left:   -FieldX,
    right:   FieldX,
    bottom:  FieldX,
    top:    -FieldX,
    znear:  0.1,
    zfar:   1000.0,
};

var editor = {
    selection: 0,
};

var sh_simple;
var vb_quad;
var ib_quad;
var ib_quad_line;
var vb_cube;
var ib_cube;
var ib_cube_line;

var entities = new Object();


function bool_s(v)      { return "bool("+v.toString()+")"; }
function int_s(v)       { return "int("+v.toString()+")"; }
function float_s(v)     { return "float("+v.toString()+")"; }
function vec2_s(x,y)    { return "vec2("+x.toString()+","+y.toString()+")"; }
function vec3_s(x,y,z)  { return "vec3("+x.toString()+","+y.toString()+","+z.toString()+")"; }
function vec4_s(x,y,z,w){ return "vec4("+x.toString()+","+y.toString()+","+z.toString()+","+w.toString()+")"; }
function string_s(v)    { return "string(\""+v+"\")"; }

function updateFPS() {
    document.getElementById("fps").textContent = frame;
    frame = 0;
}

function updateEntities()
{
    if(loading) { return; }

    loading = true;

//    var ajax = new Ajax.Request("/state/entities",
//    {
//        method: "get",
//        onComplete: function(res) {
//            loading = false;
//            entities = res.responseText.evalJSON();
//        }
//    });

     var ajax = new XMLHttpRequest();
     ajax.open("GET", "/state/entities", true);
     ajax.responseType = "arraybuffer";
     ajax.onload = function (ev) {
         loading = false;
         var buf = ajax.response;
         var pos = 0;
         entities.proj = new Float32Array(buf, pos, 16);
         pos += 4 * 16;
         var num = new Uint32Array(buf, pos, 1)[0];
         pos += 4;
         entities.ids = new Uint32Array(buf, pos, num);
         pos += 4 * num;
         entities.trans = new Float32Array(buf, pos, num*16);
         pos += 4 * 16*num;
         entities.size = new Float32Array(buf, pos, num*3);
         pos += 4 * 3*num;
         entities.color = new Float32Array(buf, pos, num*4);
         pos += 4 * 4*num;
     };
     ajax.send(null);
}

function selectEntity(p)
{
    var nearest = 0.0;
    var handle = 0;
    var radius;
    var diff = vec2.create();
    for(var i=0; i<entities.ids.length; ++i) {
        var ipp = i+1;
        var pos = entities.trans.subarray(16*i+12, 16*ipp);
        var size = entities.size.subarray(3*i, 3*ipp);
        vec2.sub(diff, p, pos);
        var radius = vec2.length(size);
        var len = vec2.length(diff);
        if(len<radius) {
            if(handle==0 || len<nearest) {
                nearest = len;
                handle = entities.ids[i];
            }
        }
    }
    editor.selection = handle;
    return handle;
}

function createShader(id)
{
    var shaderScript = document.getElementById(id);
    if(!shaderScript) { return null; }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if(shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    }
    else if(shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    }
    else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function createShaderProgram(vsid, psid)
{
    var program = gl.createProgram();
    gl.attachShader(program, createShader(vsid));
    gl.attachShader(program, createShader(psid));
    gl.linkProgram(program);
    return program;
}

var requestDraw = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { window.setTimeout(callback, delay); };
})();



function onLoadGL()
{
    var c = document.getElementById("c");
    try {
        gl = c.getContext("experimental-webgl", { depth: false });
    }
    catch(e) {
    }
    if (!gl) {
        alert("WebGL is not supported on this browser.");
        return;
    }

    sh_simple = createShaderProgram("vs_simple", "ps_simple");
    sh_simple.ia_position = gl.getAttribLocation(sh_simple, "ia_position");
    sh_simple.u_proj  = gl.getUniformLocation(sh_simple, "u_proj");
    sh_simple.u_trans = gl.getUniformLocation(sh_simple, "u_trans");
    sh_simple.u_size  = gl.getUniformLocation(sh_simple, "u_size");
    sh_simple.u_color = gl.getUniformLocation(sh_simple, "u_color");


    var quad_vertices = new Float32Array([
        -1.0, -1.0,
        -1.0,  1.0,
         1.0,  1.0,
         1.0, -1.0
    ]);
    vb_quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vb_quad);
    gl.bufferData(gl.ARRAY_BUFFER, quad_vertices, gl.STATIC_DRAW);

    var quad_indices = new Int16Array([0,1,2, 2,3,0]);
    ib_quad = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_quad);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quad_indices, gl.STATIC_DRAW);

    var quad_line_indices = new Int16Array([0,1, 1,2, 2,3, 3,0]);
    ib_quad_line = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_quad_line);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quad_line_indices, gl.STATIC_DRAW);


    var cube_vertices = new Float32Array([
         1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0,
        -1.0,-1.0, 1.0,
         1.0,-1.0, 1.0,
         1.0, 1.0,-1.0,
        -1.0, 1.0,-1.0,
        -1.0,-1.0,-1.0,
         1.0,-1.0,-1.0,
    ]);
    vb_cube = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vb_cube);
    gl.bufferData(gl.ARRAY_BUFFER, cube_vertices, gl.STATIC_DRAW);

    var cube_indices = new Int16Array([
        0,1,2, 2,3,0,
        0,4,5, 5,1,0,
        2,1,5, 5,6,2,
        3,7,4, 4,0,3,
        3,2,6, 6,7,3,
        7,6,5, 5,4,7,
    ]);
    ib_cube = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube_indices, gl.STATIC_DRAW);

    var cube_line_indices = new Int16Array([
        0,1, 1,2, 2,3, 3,0,
        0,4, 4,5, 5,1, 1,0,
        2,1, 1,5, 5,6, 6,2,
        3,7, 7,4, 4,0, 0,3,
        3,2, 2,6, 6,7, 7,3,
        7,6, 6,5, 5,4, 4,7,
    ]);
    ib_cube_line = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube_line);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube_line_indices, gl.STATIC_DRAW);
}

function drawGL()
{
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.enable(gl.CULL_FACE );
    gl.cullFace(gl.BACK);
    gl.enable(gl.BLEND);

    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.useProgram(sh_simple);
    gl.bindBuffer(gl.ARRAY_BUFFER, vb_cube);
    gl.enableVertexAttribArray(sh_simple.ia_position);
    gl.vertexAttribPointer(sh_simple.ia_position, 3, gl.FLOAT, gl.FALSE, 12, 0);

    gl.uniformMatrix4fv(sh_simple.u_proj, gl.FALSE, entities.proj);
    for(var i=0; i<entities.ids.length; ++i) {
        var ipp = i+1;
        gl.uniformMatrix4fv(sh_simple.u_trans, gl.FALSE, entities.trans.subarray(16*i, 16*ipp));
        gl.uniform3fv(sh_simple.u_size, entities.size.subarray(3*i, 3*ipp));
        if(entities.ids[i]==editor.selection) {
            gl.uniform4fv(sh_simple.u_color, [1,1,1,0.3]);
        }
        else {
            gl.uniform4fv(sh_simple.u_color, entities.color.subarray(4*i, 4*ipp));
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube_line);
        gl.drawElements(gl.LINES, 48, gl.UNSIGNED_SHORT, 0);
    }
    gl.flush();
}


function onLoad2D()
{
    var c = document.getElementById("c");
}

function draw2D()
{
    var c = document.getElementById("c");
    var w = c.width;
    var h = c.height;
    var ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.fillStyle="#000000";
    ctx.rect(0, 0, w, h);
    ctx.fill();
    ctx.stroke();

    for(var i=0; i<entities.ids.length; ++i) {
        var color = EntityClassColor2D[entities.types[i]];
        var center_x = (entities.positions[i*2+0] / FieldX * 0.5 + 0.5) * w;
        var center_y = (entities.positions[i*2+1] / FieldY *-0.5 + 0.5) * h;
        var size_x = w * (entities.sizes[i*2+0] / FieldX * 0.25);
        var size_y = h * (entities.sizes[i*2+1] / FieldY *-0.25);
        ctx.beginPath();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = color;
        ctx.rect(center_x-size_x,center_y-size_y, size_x*2,size_y*2);
        ctx.fill();
        ctx.stroke();
    }
}


function onLoad()
{
    clearInterval(FPSTimer);
    clearInterval(EntitiesTimer);

    FPSTimer = setInterval(updateFPS, 1000);
    EntitiesTimer = setInterval(updateEntities, 200);
    time = new Date().getTime() - starttime;

    document.onmousemove = function(e) {
        vec2.copy(mouse.screen_prev, mouse.screen);
        vec2.set(mouse.screen, e.pageX, e.pageY);
        var p_x = e.pageX / c.width;
        var p_y = 1.0 - (e.pageY / c.height);
        var gl_x = FieldX * (p_x-0.5)*2.0;
        var gl_y = FieldY * (p_y-0.5)*2.0;
        vec2.copy(mouse.gl_prev, mouse.gl);
        vec2.set(mouse.gl, gl_x, gl_y);

        if(mouse.dragging && editor.selection) {
            var diff = vec2.create();
            vec2.sub(diff, mouse.gl, mouse.gl_prev);
            postCommand("/call", "entity="+editor.selection+",func=move,arg="+vec2_s(diff[0],diff[1]));
        }
    };

    var c = document.getElementById("c");
    c.onmousedown = function(e) {
        mouse.dragging = true;
        e.preventDefault();
    };
    c.onmouseup = function(e) {
        mouse.dragging = false;
        if(selectEntity(mouse.gl)==0) {
            if(mouse.gl[0]<FieldX && mouse.gl[1]<FieldY) {
                postCommand("/create", "classid=0,pos="+vec2_s(mouse.gl[0], mouse.gl[1]));
            }
        }
        e.preventDefault();
    };

    // gl
    entities.proj  = new Float32Array(16);
    entities.ids   = new Uint32Array();
    entities.trans = new Float32Array();
    entities.size  = new Float32Array();
    entities.color = new Float32Array();

//    // canvas
//    entities.ids       = [];
//    entities.types     = [];
//    entities.sizes     = [];
//    entities.positions = [];

    onLoadGL();
    //onLoad2D();
    draw();
}

function draw()
{
    var t = (new Date().getTime() - starttime)*0.001;

    drawGL();
    //draw2D();

    frame++;
    setTimeout("requestDraw(draw)", delay);
}


function postCommand(url, values)
{
    var ajax = new Ajax.Request(url,
    {
        method: "post",
        parameters: values,
        onComplete: function(res) {
        }
    });
}
</script>
</head>

<body onload="onLoad()">
<canvas id="c" width="1024" height="1024" style="position:absolute; left:0px; top:0px;"></canvas>
<div id="desc" style="position:absolute; left:1024px; top:10px; with:200px;">
<span id="fps">  </span>
<a href="http://primitive-games.jp/atomic/">about atomic</a>
</div>
</body>

</html>
