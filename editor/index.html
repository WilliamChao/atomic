<!DOCTYPE html>
<html>
<head>
<title>nuclei: atomic level editor</title>

<script type="x-shader/x-vertex" id="vs_entities"> 
attribute vec3 ia_position;
uniform mat4 u_proj;
uniform mat4 u_trans;
uniform vec3 u_size;
uniform vec4 u_color;
varying vec4 vs_color;
void main()
{
    vs_color = u_color;
    gl_Position = u_proj * (u_trans* vec4(ia_position*u_size, 1.0));
}
</script>
<script type="x-shader/x-fragment" id="ps_entities">
precision mediump float;
varying vec4 vs_color;
void main()
{
    gl_FragColor = vs_color;
}
</script>

<script type="x-shader/x-vertex" id="vs_particles"> 
attribute vec2 ia_position;
uniform mat4 u_proj;
uniform float u_pointSize;
void main()
{
    gl_PointSize = u_pointSize;
    gl_Position = u_proj * vec4(ia_position, 0.0, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="ps_particles">
precision mediump float;
uniform vec4 u_color;
void main()
{
    gl_FragColor = u_color;
}
</script>

<script type="x-shader/x-vertex" id="vs_lasers"> 
attribute vec3 ia_position;
uniform mat4 u_proj;
uniform vec4 u_color;
varying vec4 vs_color;
void main()
{
    vs_color = vec4(u_color.rgb, u_color.a*ia_position.z);
    gl_Position = u_proj * vec4(ia_position.xy, 0.0, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="ps_lasers">
precision mediump float;
varying vec4 vs_color;
void main()
{
    gl_FragColor = vs_color;
}
</script>

<script type="text/javascript" src="prototype.js"></script>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript">

var EditMode = {
    Entity : 0,
    SelectEntity : 1,
    Curve : 2,
};
var Button = {
    Left    : 0,
    Middle  : 1,
    Right   : 2,
};
var FieldX = 2.56;
var FieldY = 2.56;

var gl;
var ext;

var FPSTimer;
var EntitiesTimer;
var loading = false
var frame = 0;
var delay = 1000/30;
var starttime = new Date().getTime();

var mouse = {
    screen:     vec2.create(),
    screen_prev:vec2.create(),
    pos:        vec2.create(),
    pos_prev:   vec2.create(),
    drag_begin: vec2.create(),
    dragging:   false,
    button:     0,
};

var camera = {
    pos:    vec3.fromValues(0.0, 0.0, 3.0),
    target: vec3.fromValues(0.0, 0.0, 0.0),
    up:     vec3.fromValues(0.0, 1.0, 0.0),
    aspect: 1.0,
    left:   -FieldX,
    right:   FieldX,
    bottom: -FieldX,
    top:     FieldX,
    znear:  0.1,
    zfar:   1000.0,

    view: mat4.create(),
    proj: mat4.create(),
    viewProj: mat4.create(),

    updateMatrix: function() {
        mat4.lookAt(this.view, this.pos, this.target, this.up);
        mat4.ortho(this.proj, this.left, this.right, this.bottom, this.top, this.znear, this.zfar);
        mat4.mul(this.viewProj, this.proj, this.view);
    }
};

var editor = {
    editMode: EditMode.Entity,
    entityTypes: [],
    entityTypes_IDOrder: {},
    functions: [],
    resource: 0.0,

    entitySelection: [],
    entityDeployType: 0,

    curve: {
        x: curve.createPoints(),
        y: curve.createPoints(),
    },
    curveSelection: [-1,-1],

    onMouseMove: function() {
        if(this.editMode==EditMode.Normal) {
            if(mouse.dragging && editor.entitySelection.length>0) {
                if(mouse.button==Button.Left) {
                    var diff = vec2.create();
                    vec2.sub(diff, mouse.pos, mouse.pos_prev);
                    editor.entitySelection.each(function(h){
                        callRequest(h,"move",vec2_s(diff));
                    });
                }
                else if(mouse.button==Button.Right) {
                    var diff = vec2.create();
                    vec2.sub(diff, mouse.pos, mouse.drag_begin);
                    editor.entitySelection.each(function(h){
                        callRequest(h,"orient",vec2_s(diff));
                    });
                }
            }
        }
        else if(this.editMode==EditMode.Curve) {
            if(mouse.dragging && mouse.button==Button.Left) {
                var diff = vec2.create();
                vec2.sub(diff, mouse.pos, mouse.pos_prev);
                var sel = editor.curveSelection;
                if(sel[0]!=-1) {
                    editor.curve.x[sel[0]][1] += diff[0];
                }
                if(sel[1]!=-1) {
                    editor.curve.y[sel[1]][1] += diff[1];
                }
            }
        }
    },

    onMouseDown: function() {
        if(this.editMode==EditMode.Normal) {
            if(mouse.button==Button.Left) {
                editor.clearEntitySelection();
                var selection = editor.selectEntity(mouse.pos);
                if(selection!=0) {
                    editor.addEntitySelection(selection);
                }
            }
        }
        else if(this.editMode==EditMode.Curve) {
            var s = editor.selectCurvePoint(mouse.pos);
            if(mouse.button==Button.Left) {
                if(s[0]==-1 && s[1]==-1) {
                    editor.curve.x.addPoint(curve.createPoint(editor.curve.x.endTime()+300.0, mouse.pos[0], 0.0,0.0, curve.Linear));
                    editor.curve.y.addPoint(curve.createPoint(editor.curve.y.endTime()+300.0, mouse.pos[1], 0.0,0.0, curve.Linear));
                }
                else {
                    editor.curveSelection = s;
                }
            }
            else if(mouse.button==Button.Right) {
                if(s[0]!=-1) { editor.curve.x.splice(s[0],1); }
                if(s[1]!=-1) { editor.curve.y.splice(s[1],1); }
                editor.curveSelection = [-1,-1];
            }
        }
    },

    onMouseUp: function() {
        if(this.editMode==EditMode.Normal) {
            if(mouse.button==Button.Left) {
                if(editor.entitySelection.length==0) {
                    postCommand("/nuclei/create", "classid="+editor.entityDeployType+",pos="+vec2_s(mouse.pos));
                }
            }
            else if(mouse.button==Button.Right) {
                var selection = editor.selectEntity(mouse.pos);
                editor.entitySelection.each(function(h){
                    callRequest(h,"instruct",instruction_s(mouse.pos,selection));
                });
            }
            else if(mouse.button==Button.Middle) {
                var selection = editor.selectEntity(mouse.pos);
                editor.entitySelection.each(function(h){
                    callRequest(h,"setParent",uint32_s(selection));
                });
            }
        }
        else if(this.editMode==EditMode.Curve) {
        }
    },

    clearEntitySelection: function() {
        this.entitySelection.clear();
    },
    addEntitySelection: function(e) {
        this.entitySelection.push(e);
        if(this.entitySelection.length==1) {
            ui.updateEntityProperties(e);
        }
    },
    setEntitySelection: function(e) {
        this.clearEntitySelection();
        this.entitySelection.push(e);
        if(this.entitySelection.length==1) {
            ui.updateEntityProperties(e);
        }
    },

    selectEntity: function(p)
    {
        var nearest = 0.0;
        var handle = 0;
        var diff = vec2.create();
        for(var i=0; i<entities.ids.length; ++i) {
            var ipp = i+1;
            var pos = entities.trans.subarray(16*i+12, 16*ipp);
            var size = entities.size.subarray(3*i, 3*ipp);
            vec2.sub(diff, p, pos);
            var radius = vec2.length(size);
            var len = vec2.length(diff);
            if(len<radius) {
                if(handle==0 || len<nearest) {
                    nearest = len;
                    handle = entities.ids[i];
                }
            }
        }
        return handle;
    },
    selectEntityByRect: function(bl, ur)
    {
        var handles = [];
        for(var i=0; i<entities.ids.length; ++i) {
            var ipp = i+1;
            var pos = entities.trans.subarray(16*i+12, 16*ipp);
            var size = entities.size.subarray(3*i, 3*ipp);
            var radius = vec2.length(size);
            if( (pos[0]-radius>=bl[0] && pos[0]+radius<=ur[0]) &&
                (pos[1]-radius>=bl[1] && pos[1]+radius<=ur[1]) )
            {
                handles.push(entities.ids[i]);
            }
        }
        handles.sort();
        return handles;
    },

    getEntityClassID: function(e) {
        return (e & 0xFFF00000) >>> 20;
    },
    getEntityClassName: function(e) {
        var classid = this.getEntityClassID(e);
        var typeinfo = this.entityTypes_IDOrder[classid];
        return typeinfo;
    },

    selectCurvePoint: function(p)
    {
        var xi = -1;
        var yi = -1;
        var nearest = 0.0;

        var radius = 0.1;
        var xline = editor.curve.x;
        var yline = editor.curve.y;
        var diff = vec2.create();
        for(var i=0; i<xline.length; ++i) {
            var ipp = i+1;
            var pos = vec2.fromValues(xline[i][1], yline.computeValue(xline[i][0]));
            vec2.sub(diff, p, pos);
            var len = vec2.length(diff);
            if(len<radius) {
                if(xi==-1 || len<nearest) {
                    nearest = len;
                    xi = i;
                }
            }
        }
        for(var i=0; i<yline.length; ++i) {
            var ipp = i+1;
            var pos = vec2.fromValues(xline.computeValue(yline[i][0]), yline[i][1]);
            vec2.sub(diff, p, pos);
            var len = vec2.length(diff);
            if(len<radius) {
                if(yi==-1 || len<nearest) {
                    nearest = len;
                    yi = i;
                }
            }
        }
        return [xi,yi];
    },

    setupConsts: function(consts)
    {
        this.entityTypes = consts.entityTypes;
        this.functions = consts.functions;
        for(var name in this.entityTypes) {
            var value = this.entityTypes[name];
            this.entityTypes_IDOrder[value.id] = name;
        }
    },
};

var entities = {
    ids:    new Uint32Array(),
    trans:  new Float32Array(),
    size:   new Float32Array(),
    color:  new Float32Array(),

    bullets: new Float32Array(),
    lasers: new Float32Array(),
    fluids: new Float32Array(),
};

var ui = {
    getProperties: function() { return $("entity_properties"); },
    getTypeSelector: function() { return $("entity_type_selector"); },

    createPropertyInput: function(entity, property) {
        var r = document.createElement("input");
        r.entity = entity;
        r.eprop = property;
        r.setAttribute("class", "property "+property.type);
        r.setAttribute("type", "text");
        r.setAttribute("size", 32);
        r.value = property.value;
        if(property.setter) {
            r.setAttribute("onfocus", "this.lockUpdate=true");
            r.setAttribute("onblur", "this.lockUpdate=false");
            r.setAttribute("onchange", "this.handleChange()");
            r.handleChange = function() {
                var value = this.eprop.type+"("+this.value.gsub(" ", "")+")";
                callRequest(this.entity, this.eprop.setter, value);
            }
        }
        else {
            r.disabled = true;
        }
        return r;
    },

    updateEntityProperties: function(entity)
    {
        var ajax = new Ajax.Request("/nuclei/entity", {
            method: "post",
            parameters: "entity="+entity,
            onComplete: function(res) {
                var properties = res.responseText.evalJSON();
                var fields = ui.getProperties();
                var parent = properties.find( function(a){return a.name=="parent";} );
                clearChildren(fields);
                {
                    var classname = editor.getEntityClassName(entity);
                    var t = document.createElement("li");
                    t.appendChild(document.createTextNode(classname));
                    fields.appendChild(t);
                }
                {
                    var button = document.createElement("input");
                    button.setAttribute("type", "button");
                    button.value = "delete";
                    button.nuEntity = entity;
                    button.onclick = function(){
                        postCommand("/nuclei/delete", "entity="+this.nuEntity);
                    };
                    var t = document.createElement("li");
                    t.appendChild(button);
                    fields.appendChild(t);
                }
                if(parent) {
                    var button = document.createElement("input");
                    button.setAttribute("type", "button");
                    button.value = "select parent";
                    button.nuParent = parent.value;
                    button.onclick = function(){
                        editor.setEntitySelection(this.nuParent);
                    };
                    var t = document.createElement("li");
                    t.appendChild(button);
                    fields.appendChild(t);
                }
                each(properties, function(field){
                    var t = document.createElement("li");
                    t.setAttribute("class", "property");
                    t.appendChild(document.createTextNode(field.name+"("+field.type+") "));
                    t.appendChild(ui.createPropertyInput(entity, field));
                    t.entityProperty = field;
                    fields.appendChild(t);
                });
            }
        });
    },

    onClickEntityType: function()
    {
        var selector = ui.getTypeSelector();
        each(selector.childNodes, function(e){
            e.style.backgroundColor = "";
        });
        editor.entityDeployType = this.entitytype;
        this.style.backgroundColor = "#FF0000";
    },

    updateCurveProperties: function()
    {
        var root = $("curve_properties");
    },

    onLoad: function()
    {
        var ajax = new Ajax.Request("/nuclei/const", {
            method: "get",
            onComplete: function(res) {
                var consts = res.responseText.evalJSON();
                editor.setupConsts(consts);

                var selector = ui.getTypeSelector();
                for(var name in editor.entityTypes) {
                    var value = editor.entityTypes[name];
                    if(!value.deployable) { continue; }
                    var t = document.createElement("li");
                    t.setAttribute("class", "entitytype");
                    t.appendChild(document.createTextNode(name));
                    t.entitytype = value.id;
                    t.onclick = ui.onClickEntityType;
                    selector.appendChild(t);
                }
            }
        });
    }
};

var sh_entities;
var sh_particles;
var sh_lasers;
var vb_quad;
var ib_quad;
var ib_quad_line;
var vb_cube;
var ib_cube;
var ib_cube_line;
var vb_bullets;
var vb_lasers;
var vb_fluids;
var vb_curve;
var vb_curve_points;


function bool_s(v)  { return "bool("+v.toString()+")"; }
function int32_s(v)   { return "int32("+v.toString()+")"; }
function uint32_s(v)  { return "uint32("+v.toString()+")"; }
function float32_s(v) { return "float32("+v.toString()+")"; }
function vec2_s(v)  { return "vec2("+v[0].toString()+","+v[1].toString()+")"; }
function vec3_s(v)  { return "vec3("+v[0].toString()+","+v[1].toString()+","+v[2].toString()+")"; }
function vec4_s(v)  { return "vec4("+v[0].toString()+","+v[1].toString()+","+v[2].toString()+","+v[3].toString()+")"; }
function string_s(v){ return "string(\""+v+"\")"; }
function instruction_s(p,e) { return "instruction("+p[0].toString()+","+p[1].toString()+",0.0,"+e.toString()+")"; }

function updateFPS() {
    document.getElementById("fps").textContent = frame;
    frame = 0;
}

function updateEntities()
{
    if(loading) { return; }

    loading = true;

    var ajax = new XMLHttpRequest();
    ajax.open("GET", "/nuclei/state", true);
    ajax.responseType = "arraybuffer";
    ajax.onload = function (ev) {
        loading = false;
        var buf = ajax.response;
        var rpos = 0;

        var nums = new Uint32Array(buf, rpos, 4);
        rpos += 4*4;
        var num_entities = nums[0];
        var num_bullets = nums[1];
        var num_lasers = nums[2];
        var num_fluids = nums[3];
    
        entities.ids = new Uint32Array(buf, rpos, num_entities);
        rpos += 4 * num_entities;
        entities.trans = new Float32Array(buf, rpos, num_entities*16);
        rpos += 4*16 * num_entities;
        entities.size = new Float32Array(buf, rpos, num_entities*3);
        rpos += 4*3 * num_entities;
        entities.color = new Float32Array(buf, rpos, num_entities*4);
        rpos += 4*4 * num_entities;

        entities.bullets = new Float32Array(buf, rpos, num_bullets*2);
        rpos += 4*2 * num_bullets;

        entities.lasers = new Float32Array(buf, rpos, num_lasers*3);
        rpos += 4*3 * num_lasers;

        entities.fluids = new Float32Array(buf, rpos, num_fluids*2);
        rpos += 4*2 * num_fluids;
    };
    ajax.send(null);
}


function createShader(id)
{
    var shaderScript = document.getElementById(id);
    if(!shaderScript) { return null; }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if(shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    }
    else if(shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    }
    else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function createShaderProgram(vsid, psid)
{
    var program = gl.createProgram();
    gl.attachShader(program, createShader(vsid));
    gl.attachShader(program, createShader(psid));
    gl.linkProgram(program);
    return program;
}

var requestDraw = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { window.setTimeout(callback, delay); };
})();



function onLoadGL()
{
    var c = document.getElementById("c");
    try {
        gl = c.getContext("experimental-webgl", { depth: false });
    }
    catch(e) {
    }
    if (!gl) {
        alert("WebGL is not supported on this browser.");
        return;
    }

    sh_entities = createShaderProgram("vs_entities", "ps_entities");
    sh_entities.ia_position = gl.getAttribLocation(sh_entities, "ia_position");
    sh_entities.u_proj  = gl.getUniformLocation(sh_entities, "u_proj");
    sh_entities.u_trans = gl.getUniformLocation(sh_entities, "u_trans");
    sh_entities.u_size  = gl.getUniformLocation(sh_entities, "u_size");
    sh_entities.u_color = gl.getUniformLocation(sh_entities, "u_color");

    sh_particles = createShaderProgram("vs_particles", "ps_particles");
    sh_particles.ia_position = gl.getAttribLocation(sh_particles, "ia_position");
    sh_particles.u_proj  = gl.getUniformLocation(sh_particles, "u_proj");
    sh_particles.u_pointSize  = gl.getUniformLocation(sh_particles, "u_pointSize");
    sh_particles.u_color = gl.getUniformLocation(sh_particles, "u_color");

    sh_lasers = createShaderProgram("vs_lasers", "ps_lasers");
    sh_lasers.ia_position = gl.getAttribLocation(sh_lasers, "ia_position");
    sh_lasers.u_proj  = gl.getUniformLocation(sh_lasers, "u_proj");
    sh_lasers.u_color = gl.getUniformLocation(sh_lasers, "u_color");


    var quad_vertices = new Float32Array([
        -1.0, -1.0,
        -1.0,  1.0,
         1.0,  1.0,
         1.0, -1.0
    ]);
    vb_quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vb_quad);
    gl.bufferData(gl.ARRAY_BUFFER, quad_vertices, gl.STATIC_DRAW);

    var quad_indices = new Int16Array([0,1,2, 2,3,0]);
    ib_quad = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_quad);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quad_indices, gl.STATIC_DRAW);

    var quad_line_indices = new Int16Array([0,1, 1,2, 2,3, 3,0]);
    ib_quad_line = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_quad_line);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, quad_line_indices, gl.STATIC_DRAW);


    var cube_vertices = new Float32Array([
         1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0,
        -1.0,-1.0, 1.0,
         1.0,-1.0, 1.0,
         1.0, 1.0,-1.0,
        -1.0, 1.0,-1.0,
        -1.0,-1.0,-1.0,
         1.0,-1.0,-1.0,
    ]);
    vb_cube = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vb_cube);
    gl.bufferData(gl.ARRAY_BUFFER, cube_vertices, gl.STATIC_DRAW);

    var cube_indices = new Int16Array([
        0,1,2, 2,3,0,
        0,4,5, 5,1,0,
        2,1,5, 5,6,2,
        3,7,4, 4,0,3,
        3,2,6, 6,7,3,
        7,6,5, 5,4,7,
    ]);
    ib_cube = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube_indices, gl.STATIC_DRAW);

    var cube_line_indices = new Int16Array([
        0,1, 1,2, 2,3, 3,0,
        0,4, 4,5, 5,1, 1,0,
        2,1, 1,5, 5,6, 6,2,
        3,7, 7,4, 4,0, 0,3,
        3,2, 2,6, 6,7, 7,3,
        7,6, 6,5, 5,4, 4,7,
    ]);
    ib_cube_line = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube_line);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube_line_indices, gl.STATIC_DRAW);

    vb_bullets = gl.createBuffer();
    vb_lasers = gl.createBuffer();
    vb_fluids = gl.createBuffer();
    vb_curve = gl.createBuffer();
    vb_curve_points = gl.createBuffer();
}

function drawGL()
{
    camera.updateMatrix();
    var projection = camera.viewProj;

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.enable(gl.CULL_FACE );
    gl.cullFace(gl.BACK);
    gl.enable(gl.BLEND);

    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.useProgram(sh_entities);
    gl.bindBuffer(gl.ARRAY_BUFFER, vb_cube);
    gl.enableVertexAttribArray(sh_entities.ia_position);
    gl.vertexAttribPointer(sh_entities.ia_position, 3, gl.FLOAT, gl.FALSE, 12, 0);
    gl.uniformMatrix4fv(sh_entities.u_proj, gl.FALSE, projection);
    for(var i=0; i<entities.ids.length; ++i) {
        var ipp = i+1;
        gl.uniformMatrix4fv(sh_entities.u_trans, gl.FALSE, entities.trans.subarray(16*i, 16*ipp));
        gl.uniform3fv(sh_entities.u_size, entities.size.subarray(3*i, 3*ipp));
        if(editor.entitySelection.include(entities.ids[i])) {
            gl.uniform4fv(sh_entities.u_color, [1,1,1,0.3]);
        }
        else {
            gl.uniform4fv(sh_entities.u_color, entities.color.subarray(4*i, 4*ipp));
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib_cube_line);
        gl.drawElements(gl.LINES, 48, gl.UNSIGNED_SHORT, 0);
    }


    if(entities.fluids.length) {
        gl.useProgram(sh_particles);
        gl.bindBuffer(gl.ARRAY_BUFFER, vb_fluids);
        gl.bufferData(gl.ARRAY_BUFFER, entities.fluids, gl.STREAM_DRAW);
        gl.enableVertexAttribArray(sh_particles.ia_position);
        gl.vertexAttribPointer(sh_particles.ia_position, 2, gl.FLOAT, gl.FALSE, 8, 0);
        gl.uniformMatrix4fv(sh_particles.u_proj, gl.FALSE, projection);
        gl.uniform4fv(sh_particles.u_color, [0.0, 0.5, 1.0, 0.3]);
        gl.uniform1f(sh_particles.u_pointSize, 5.0);
        gl.drawArrays(gl.POINTS, 0, entities.fluids.length/2);
    }
    if(entities.bullets.length) {
        gl.useProgram(sh_particles);
        gl.bindBuffer(gl.ARRAY_BUFFER, vb_bullets);
        gl.bufferData(gl.ARRAY_BUFFER, entities.bullets, gl.STREAM_DRAW);
        gl.enableVertexAttribArray(sh_particles.ia_position);
        gl.vertexAttribPointer(sh_particles.ia_position, 2, gl.FLOAT, gl.FALSE, 8, 0);
        gl.uniformMatrix4fv(sh_particles.u_proj, gl.FALSE, projection);
        gl.uniform4fv(sh_particles.u_color, [1.0, 1.0, 0.0, 1.0]);
        gl.uniform1f(sh_particles.u_pointSize, 8.0);
        gl.drawArrays(gl.POINTS, 0, entities.bullets.length/2);
    }
    if(entities.lasers.length) {
        gl.useProgram(sh_lasers);
        gl.bindBuffer(gl.ARRAY_BUFFER, vb_lasers);
        gl.bufferData(gl.ARRAY_BUFFER, entities.lasers, gl.STREAM_DRAW);
        gl.enableVertexAttribArray(sh_lasers.ia_position);
        gl.vertexAttribPointer(sh_lasers.ia_position, 3, gl.FLOAT, gl.FALSE, 12, 0);
        gl.uniformMatrix4fv(sh_lasers.u_proj, gl.FALSE, projection);
        gl.uniform4fv(sh_lasers.u_color, [1.0, 1.0, 0.0, 1.0]);
        gl.lineWidth(10.0);
        gl.drawArrays(gl.LINES, 0, entities.lasers.length/3);
        gl.lineWidth(1.0);
    }

    if(editor.editMode==EditMode.Curve) {
        var xline = editor.curve.x;
        var yline = editor.curve.y;
        var xv = xline.sampling(10.0);
        var yv = yline.sampling(10.0);
        var vertices = [];
        for(var i=0; i<xv.length; ++i) {
            vertices.push(xv[i]);
            vertices.push(yv[i]);
        }
        gl.useProgram(sh_particles);
        gl.bindBuffer(gl.ARRAY_BUFFER, vb_curve_points);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STREAM_DRAW);
        gl.enableVertexAttribArray(sh_particles.ia_position);
        gl.vertexAttribPointer(sh_particles.ia_position, 2, gl.FLOAT, gl.FALSE, 8, 0);
        gl.uniformMatrix4fv(sh_particles.u_proj, gl.FALSE, projection);
        gl.uniform4fv(sh_particles.u_color, [0.75, 0.75, 1.0, 0.5]);
        gl.uniform1f(sh_particles.u_pointSize, 4.0);
        gl.drawArrays(gl.POINTS, 0, vertices.length/2);
        gl.drawArrays(gl.LINE_STRIP, 0, vertices.length/2);

        vertices.clear();
        for(var i=0; i<xline.length; ++i) {
            vertices.push(xline[i][1]);
            vertices.push(yline.computeValue(xline[i][0]));
        }
        for(var i=0; i<yline.length; ++i) {
            vertices.push(xline.computeValue(yline[i][0]));
            vertices.push(yline[i][1]);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, vb_curve_points);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STREAM_DRAW);
        gl.uniform1f(sh_particles.u_pointSize, 8.0);
        gl.drawArrays(gl.POINTS, 0, vertices.length/2);
    }

    gl.flush();
}


function onLoad()
{
    clearInterval(FPSTimer);
    clearInterval(EntitiesTimer);

    FPSTimer = setInterval(updateFPS, 1000);
    EntitiesTimer = setInterval(updateEntities, 200);
    time = new Date().getTime() - starttime;

    var c = document.getElementById("c");

    document.oncontextmenu = function() { return false; };

    document.onmousemove = function(e) {
        vec2.copy(mouse.screen_prev, mouse.screen);
        vec2.set(mouse.screen, e.pageX, e.pageY);
        var p_x = e.pageX / c.width;
        var p_y = 1.0 - (e.pageY / c.height);
        var gl_x = FieldX * (p_x-0.5)*2.0;
        var gl_y = FieldY * (p_y-0.5)*2.0;
        vec2.copy(mouse.pos_prev, mouse.pos);
        vec2.set(mouse.pos, gl_x, gl_y);
        editor.onMouseMove();
    };

    c.onmousedown = function(e) {
        mouse.dragging = true;
        mouse.button = e.button;
        editor.onMouseDown();
        e.preventDefault();
    };

    c.onmouseup = function(e) {
        mouse.dragging = false;
        editor.onMouseUp();
        e.preventDefault();
    };

    ui.onLoad();

    onLoadGL();
    draw();
}

function draw()
{
    var t = (new Date().getTime() - starttime)*0.001;

    drawGL();
    frame++;
    setTimeout("requestDraw(draw)", delay);
}

function callRequest(entity, funcname, arg)
{
    var command = entity.toString()+"->"+funcname+"("+arg+")";
    postCommand("/nuclei/call", command);
}

function postCommand(url, values)
{
    var ajax = new Ajax.Request(url,
    {
        method: "post",
        parameters: values,
        onComplete: function(res) {
        }
    });
}

</script>
</head>

<body onload="onLoad()">
<canvas id="c" width="1024" height="1024" style="position:absolute; left:0px; top:0px;"></canvas>
<div id="tools" style="position:absolute; left:1024px; top:0px; with:200px;">
<span id="fps">00</span><ul id="entity_type_selector"></ul><ul id="entity_properties"></ul><ul id="entity_list"></ul><ul id="curve_properties"></ul>
<a href="http://primitive-games.jp/atomic/">about atomic</a>
</div>
</body>

</html>
